#!/bin/bash -e

. /usr/lib/fatc/common


FATC_DAEMON_CONFIG='.daemons // {} | .[$stack_name] // {}'
FATC_SERVICE_CONFIG='.services // {} | .[$stack_name] // {}'
FATC_STACK_CONFIG='.[$stack_type] // {} | .[$stack_name] // {}'


fatc_configure_proxy_socket () {
    local listen
    protocol=ListenStream
    listen="$4"
    if [ "${listen: -4}" = "/udp" ]; then
	protocol=ListenDatagram
	listen="${listen::-4}"
    fi
    PROXY_SOCKET="${FATC_SYSTEMD}/fatc.${1}.${2}.${3}--proxy.socket"
    cat > "$PROXY_SOCKET" <<EOF
[Socket]
$protocol=$listen
[Install]
WantedBy=sockets.target
EOF
}


fatc_configure_proxy_service () {
    PROXY_SERVICE="${FATC_SYSTEMD}/fatc.${1}.${2}.${3}--proxy.service"
    cat > "$PROXY_SERVICE" <<EOF
[Unit]
Description=Proxy $1 service: $2.$3
Requires=fatc.$1.$2.service
After=fatc.$1.$2.service
[Service]
ExecStart=/usr/bin/fatctl start-proxy $1 $2 $3 $4
PrivateTmp=yes
EOF
}


fatc_configure_isolated_daemon () {
    SERVICE="${FATC_SYSTEMD}/fatc.daemon.${1}.service"
    cat > "$SERVICE" <<EOF
[Unit]
Description=Daemon service: $1
Requires=configuration.service $2
After=configuration.service $2

[Install]
WantedBy=fatc.target
[Service]
ExecStart=/usr/bin/fatctl start-daemon-stack $1
ExecStop=/usr/bin/fatctl stop-daemon-stack $1
PassEnvironment=FATC_DAEMONS
PassEnvironment=FATC_DAEMONS_SOCKETS
PassEnvironment=FATC_COMPOSE
RemainAfterExit=true
EOF
}


fatc_configure_daemon_service () {
    SERVICE="${FATC_SYSTEMD}/fatc.daemon.${1}.service"
    cat > "$SERVICE" <<EOF
[Unit]
Description=Daemon service: $1
Requires=configuration.service $5
After=configuration.service $5
[Install]
WantedBy=fatc.target
[Service]
ExecStart=/usr/bin/fatctl start-daemon-stack $1 $4
ExecStartPost=/usr/bin/fatctl wait-daemon-stack 0.5 $1 "$2" $3
ExecStop=/usr/bin/fatctl stop-daemon-stack $1 $4
PassEnvironment=FATC_DAEMONS
PassEnvironment=FATC_DAEMONS_SOCKETS
PassEnvironment=FATC_COMPOSE
PassEnvironment=FATC_TIMEOUT_SOCKETS
RemainAfterExit=true
EOF
}


fatc_configure_service_service () {
    SERVICE="${FATC_SYSTEMD}/fatc.service.${1}.service"
    cat > "$SERVICE" <<EOF
[Unit]
Description=Service service: $1
Requires=configuration.service $5
After=configuration.service $5
[Install]
WantedBy=fatc.target
[Service]
ExecStart=/usr/bin/fatctl start-service-stack $1 $4
ExecStartPost=/usr/bin/fatctl wait-service-stack 0.5 $1 "$2" $3
ExecStop=/usr/bin/fatctl stop-service-stack $1 $4
PassEnvironment=FATC_SERVICES
PassEnvironment=FATC_SERVICES_SOCKETS
PassEnvironment=FATC_COMPOSE
PassEnvironment=FATC_USE_CRIU
PassEnvironment=FATC_CRIU
PassEnvironment=FATC_CONTAINERS
PassEnvironment=FATC_TIMEOUT_SOCKETS
RemainAfterExit=true
EOF
}


fatc_configure_backend () {
    SERVICE="${FATC_SYSTEMD}/fatc.service.${1}.service"
    cat > "$SERVICE" <<EOF
[Unit]
Description=Service service: $1.$2
[Install]
WantedBy=fatc.target
[Service]
ExecStart=/usr/bin/fatctl start-backend $1
ExecStartPost=/usr/bin/fatctl wait-backend 0.5 $1 $2 "$3" $4
ExecStop=/usr/bin/fatctl stop-backend $1
PassEnvironment=FATC_SERVICES
PassEnvironment=FATC_SERVICES_SOCKETS
PassEnvironment=FATC_TIMEOUT_SOCKETS
RemainAfterExit=true
EOF
}


fatc_configure_service_idle () {
    local COMPOSE fun idle_fun service stack_name stack_type
    stack_type=$1
    stack_name=$2
    idle_fun=$3
    COMPOSE=$(fatc_get_stack_compose_command "$stack_type" "$stack_name")
    export COMPOSE
    fun=$(echo "$idle_fun" | envsubst '${COMPOSE}')
    service=$(echo '{}' | jq -cr --arg idle "$fun" '.idle = $idle')
    if [ ! -f "$FATC_IDLE" ]; then
	mkdir -p "$(dirname "$FATC_IDLE")"
	echo "{}" > "$FATC_IDLE"
    fi
    jq --arg stack_name "${stack_name}" \
       --argjson service "$service" \
       '.[$stack_name] = $service' "$FATC_IDLE" \
	| sponge "$FATC_IDLE"
}


fatc_get_listen_address () {
    if [ "$1" == ":unix:" ]; then
	fatc_get_listen_socket "$2" "$3"
    elif [[ "$listen" == :* ]];then
	network=$(echo "$1" | cut -d: -f2)
	port=$(echo "$1" | cut -d: -f3)
	address=$(docker network inspect "fatc_${network}" \
		      | jq -r '.[].IPAM.Config[].Gateway')
	echo "${address}:${port}"
    else
	echo "$1"
    fi
}


fatc_get_upstream_address () {
    if [ "$1" = ":unix:" ]; then
	fatc_get_upstream_socket "$2" "$3" "$4"
    else
	echo "$1"
    fi
}


fatc_configure_track () {
    local config compose healthy index line listen \
	  private_network result \
	  services stack_name stack_type \
	  upstream
    stack_type=$1
    stack_name=$2
    index=$3
    track=$(echo "${4}" | base64 --decode)
    listen=$(echo "${track}" | jq -r ".listen // empty")
    upstream=$(echo "${track}" | jq -r ".upstream // empty")
    result=()
    private_network=no
    if [[ "$upstream" = ":unix:" && "$listen" = ":unix:" ]]; then
	private_network=yes
    fi
    upstream=$(fatc_get_upstream_address "$upstream" "$stack_type" "$stack_name" "$index")
    listen=$(fatc_get_listen_address "$listen" "$stack_name" "$index")
    fatc_configure_proxy_service "$stack_type" "$stack_name" "$index" "$upstream" "$private_network"
    fatc_configure_proxy_socket "$stack_type" "$stack_name" "$index" "$listen"
    systemctl enable "fatc.${stack_type}.${stack_name}.${index}--proxy.socket"
    result+=("${stack_type}.${stack_name}: <- $listen")
    compose=$(fatc_get_stack_compose "$stack_type" "$stack_name")
    if [ -f "$compose" ]; then
	services=$(fatc_get_stack_services "$stack_type" "$stack_name")
	result+=("${stack_type}.${stack_name}: -> docker: $upstream (${services%%*( )})")
    fi
    if [[ ! -f "$compose" || $index != 0 ]]; then
	config=$(jq -cr \
		    --arg stack_name "$stack_name" \
		    --arg stack_type "${stack_type}s" \
		    "$FATC_STACK_CONFIG" \
		    "$FATC_CONFIG")
	healthy=$(echo "$config" | jq -cr ".tracks // [] | .[$i] // {} | .healthy")
	fatc_configure_backend "$stack_name" "$index" "$healthy" "$upstream"
	systemctl enable "fatc.${stack_type}.${stack_name}"
	result+=("${stack_type}.${stack_name}: -> $upstream")
    fi
    for line in "${result[@]}"; do
	fatc_log "$line"
    done
}


fatc_get_tracks () {
    local stack_name stack_type
    stack_type="$1"
    stack_name="$2"
    jq -cr \
       --arg stack_name "${stack_name}" \
       --arg stack_type "${stack_type}s" \
       "$FATC_STACK_CONFIG | .tracks // [] | .[] | @base64" \
       "$FATC_CONFIG"
}


fatc_configure_tracks () {
    local i stack_name stack_type track
    stack_type="$1"
    stack_name="$2"
    i=0
    for track in $(fatc_get_tracks "$stack_type" "$stack_name"); do
	fatc_configure_track "$stack_type" "$stack_name" "$i" "$track"
	i=$((i + 1))
    done
}


fatc_configure_composition () {
    local compose dependency depends depends_on idle_fun \
	  stack_name stack_type \
	  services track_count use_criu
    stack_type="$1"
    stack_name="$2"
    track_count=$(fatc_get_tracks "$stack_type" "$stack_name" | wc -l)
    compose=$(fatc_get_stack_compose "$stack_type" "$stack_name")
    if [ ! -f "$compose" ]; then
	return
    fi
    config=$(jq -cr \
		--arg stack_name "$stack_name" \
		--arg stack_type "${stack_type}s" \
		"$FATC_STACK_CONFIG" \
		"$FATC_CONFIG")
    healthy=$(echo "$config" | jq -cr ".tracks // [] | .[0] // {} | .healthy")
    upstream=$(echo "$config" | jq -cr ".tracks // [] | .[0] // {} | .upstream")
    if [ "$upstream" = ":unix:" ]; then
	upstream=$(fatc_get_upstream_socket "$stack_type" "$stack_name" 0)
    fi
    use_criu=$(echo "$config" | jq -cr ".use_criu // false")
    depends_on=$(echo "$config" | jq -cr '.depends_on // [] | join (" ")')
    depends=""
    for dependency in $depends_on; do
	depends="${depends} fatc.daemon.${dependency}.service"
    done
    if [[ "$track_count" = 0 && "$stack_type" = "daemon" ]]; then
	fatc_configure_isolated_daemon "$stack_name" "$depends"
	services=$(fatc_get_stack_services "$stack_type" "$stack_name")
	fatc_log "daemon.${stack_name}: docker: ${services%%*( )}"
    else
	fatc_configure_"$stack_type"_service "$stack_name" "$healthy" "$upstream" "$use_criu" "$depends"
	# fatc_configure_update_services "$stack_type" "$stack_name" "$index" "$listen" "$upstream" "$services"
    fi
    systemctl enable "fatc.${stack_type}.${stack_name}"
    if [ "$stack_type" = "service" ]; then
	idle_fun=$(jq -cr \
		      --arg stack_name "$stack_name" \
		      "$FATC_SERVICE_CONFIG | .idle // empty" \
		      "$FATC_CONFIG")
	if [ -z "$idle_fun" ]; then
	    fatc_log_warn "Service ($stack_name) has no idle function and will never timeout"
	else
	    fatc_configure_service_idle "$stack_type" "$stack_name" "$idle_fun"
	fi
    fi
}


fatc_configure_stack () {
    local stack_name \
	  stack_type
    stack_type=$1
    stack_name=$2
    fatc_configure_tracks "$stack_type" "$stack_name"
    fatc_configure_composition "$stack_type" "$stack_name"
}


fatc_configure_daemon () {
    fatc_configure_stack daemon "$1"
}


fatc_configure_service () {
    fatc_configure_stack service "$1"
}


fatc_configure_start_service () {
    # only the socket - ie no stack is activated for services
    # stacks are activated dynamically when the socket is tickled
    local i track
    i=0
    for track in $(fatc_get_tracks service "$1"); do
	systemctl start "fatc.service.${1}.${i}--proxy.socket"
	i=$((i + 1))
    done
}


fatc_configure_start_daemon () {
    local compose i track
    i=0
    for track in $(fatc_get_tracks daemon "$1"); do
	systemctl start "fatc.daemon.${1}.${i}--proxy.socket"
	i=$((i + 1))
    done
    compose=$(fatc_get_stack_compose daemon "$1")
    if [ -f "$compose" ]; then
	systemctl start "fatc.daemon.${1}"
    fi
}


fatc_configure_parallel () {
    local dir stack_type runtype
    runtype="$1"
    stack_type="$2"
    dir=$(fatc_get_stack_dir "$stack_type")
    if [ -d "$dir" ]; then
	fatc_parallel "fatc_ls_dirs ${dir}" "fatc_${runtype}_${stack_type}"
    else
	fatc_log "No ${stack_type}s to ${runtype}"
    fi
}


fatc_configure_networks () {
    local cmd configured network network_name networks
    networks=$(jq -cr  '.networks // {} | keys | join(" ")' "$FATC_CONFIG")
    configured=$(docker network ls)
    for network in $networks; do
	network_name="fatc_${network}"
	subnet=$(jq -cr --arg network "$network"  '.networks // {} | .[$network].subnet // empty' "$FATC_CONFIG")
	# not sure if this should cane network and recreate if it exists
	# to enforce config
	if ! grep -q "$network_name" <<<"$configured" ; then
	    opts=""
	    if [ -n "$subnet" ]; then
		opts=" --subnet=$subnet"
	    fi
	    cmd="docker network create $opts $network_name"
	    $cmd
	fi
    done
}


fatc_configure_volumes () {
    local cmd volume volumes
    volumes=$(jq -cr  '.volumes // {} | keys | join(" ")' "$FATC_CONFIG")
    for volume in $volumes; do
	owner=$(jq -cr --arg volume "$volume"  '.volumes // {} | .[$volume].owner // empty' "$FATC_CONFIG")
	permissions=$(jq -cr --arg volume "$volume"  '.volumes // {} | .[$volume].permissions // empty' "$FATC_CONFIG")
	mkdir -p "$volume"
	if [ -n "$owner" ]; then
	    chown "$owner" "$volume"
	fi
	if [ -n "$permissions" ]; then
	    chmod "$permissions" "$volume"
	fi
    done
}


fatc_configure () {
    export -f fatc_configure_backend
    export -f fatc_configure_composition
    export -f fatc_configure_track
    export -f fatc_configure_tracks
    export -f fatc_configure_stack
    export -f fatc_configure_proxy_service
    export -f fatc_configure_proxy_socket
    # export -f fatc_configure_update_services

    export -f fatc_configure_service
    export -f fatc_configure_service_service
    export -f fatc_configure_service_idle
    export -f fatc_configure_start_service

    export -f fatc_configure_daemon
    export -f fatc_configure_daemon_service
    export -f fatc_configure_isolated_daemon
    export -f fatc_configure_start_daemon
    export -f fatc_log
    export -f fatc_log_warn
    export -f fatc_log_err

    export -f fatc_get_listen_socket
    export -f fatc_get_listen_address
    export -f fatc_get_stack_compose
    export -f fatc_get_stack_compose_command
    export -f fatc_get_stack_dir
    export -f fatc_get_stack_services
    export -f fatc_get_sockets_dir
    export -f fatc_get_tracks
    export -f fatc_get_upstream_address
    export -f fatc_get_upstream_socket

    export FATC_COMPOSE
    export FATC_CONFIG
    export FATC_DAEMON_CONFIG
    export FATC_DAEMONS
    export FATC_DAEMONS_SOCKETS
    export FATC_PROXY_SOCKETS
    export FATC_SERVICE_CONFIG
    export FATC_SERVICES
    export FATC_SERVICES_SOCKETS
    export FATC_STACK_CONFIG
    export FATC_SYSTEMD

    fatc_configure_networks
    fatc_configure_volumes
    fatc_configure_parallel configure daemon
    fatc_configure_parallel configure service
    fatc_configure_parallel configure_start service
    fatc_configure_parallel configure_start daemon
}
